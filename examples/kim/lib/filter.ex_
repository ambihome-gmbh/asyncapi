defmodule Kim.Filter do
  import Enum

  # {
  #   "IRI": "http://schema.knx.org/2020/ontology/knx#dpa.414.51",
  #   "Label": "Switch OnOff",
  #   "Identifier": "urn:knx:dpa.414.51",
  #   "Description": null,
  #   "DPT": {
  #     "IRI": "http://schema.knx.org/2020/ontology/knx#switch",
  #     "Identifier": "urn:knx:dpt.switch"
  #   },
  #   "QualityKind": "qk_eq_luminaire_dimmlevel",
  #   "OperationKind": {
  #     "hasStateType": [
  #       "on",
  #       "off"
  #     ],
  #     "hasPointFunctionType": [
  #       "activation"
  #     ],
  #     "hasPointOperation": [
  #       "enumeration"
  #     ],
  #     "refersTo": [
  #       "qk_eq_luminaire_dimmlevel"
  #     ]
  #   }
  # },

  def apply(collection, filters) do
    filters = normalize_filters(filters)

    # dbg({inf, filters})

    reduce(filters, collection, fn
      {scope, {op, value}}, acc ->
        filter(acc, &apply_filter(&1, scope, {op, value}))
    end)
  end

  defp normalize_filters(filters) do
    for {scope, value} <- filters do
      # NOTE: for comparison we have to
      # 1. Look up the field definition in the JSON schema (or your own internal schema)
      # 2. Determine the type (string, number, time, boolean, IRI, etc.)
      # 3. Cast the value(s) accordingly
      # 4. Apply the comparison using Elixir logic (e.g. <=, in, DateTime.compare/2, etc.)

      # NOTE: we cant cast value here, because it may be in a CSV and we know that only later (just below)

      {normalize_filter_scope(scope), normalize_filter_value(value)}
    end
  end

  defp normalize_filter_value(value) do
    case value do
      %{"eq" => value} -> {"eq", value}
      %{"le" => value} -> {"le", value}
      %{"ge" => value} -> {"ge", value}
      %{"lt" => value} -> {"lt", value}
      %{"gt" => value} -> {"gt", value}
      %{"and" => [_ | _] = values} -> {"and", values}
      %{"or" => [_ | _] = values} -> {"or", values}
      literal when not is_map(literal) -> {"eq", literal}
      unexpected -> raise("Unexpected filter value: #{inspect(unexpected)}")
    end
  end

  def normalize_filter_scope(scope) do
    case split_trim(scope, ".") do
      ["hasPointInterface"] ->
        [tag("hasPointInterface")]

      ["operatesForTrade"] ->
        [tag("operatesForTrade")]

      ["hasLocationUsage"] ->
        [tag("hasLocationUsage")]

      ["operatesOnProtocol"] ->
        [tag("operatesOnProtocol")]

      ["actsOnPhenomenonQualityKind", tag] ->
        qualkind_path(tag, "actsOnPhenomenonQualityKind")

      ["observesPhenomenonQualityKind", tag] ->
        qualkind_path(tag, "observesPhenomenonQualityKind")

      ["adjustsEquipmentQualityKind", tag] ->
        qualkind_path(tag, "adjustsEquipmentQualityKind")

      ["hasQualityKind", tag] ->
        qualkind_path(tag, :all)

      ["hasOperationKind", tag] ->
        opkind_path(tag)

      [literal_attribute] ->
        [literal_attribute]

      [_ | _] = object_attribute_path ->
        object_attribute_path

      unexpected ->
        raise("Unexpected filter scope: #{inspect(unexpected)}")
    end
  end

  defp opkind_path(tag) do
    ["attributes", "operationKinds", Access.all(), tag(tag)]
  end

  defp qualkind_path(tag, accessor) do
    accessor_fn =
      if accessor == :all do
        Access.all()
      else
        Access.filter(&(&1["tagset"] == accessor))
      end

    ["qualitykinds", accessor_fn, tag(tag)]
  end

  defp tag(string), do: "tag:#{string}"
  def split_trim(string, separator), do: string |> String.split(separator) |> map(&String.trim/1)

  defp apply_filter(item, scope, {op, value}) do
    all_resolved = resolve_scope(item, scope)

    filter_results =
      for resolved <- all_resolved do
        resolved_list =
          if is_tuple(resolved) do
            Tuple.to_list(resolved)
          else
            [resolved]
          end

        case {resolved_list, op} do
          {[resolved], "eq"} -> resolved == value
          # not sure how to handle eq with resolved list !!?? TODO
          {_, "eq"} -> value in resolved_list
          {[resolved], "le"} -> resolved <= value
          {[resolved], "ge"} -> resolved >= value
          {[resolved], "lt"} -> resolved < value
          {[resolved], "gt"} -> resolved > value
          {_, "and"} -> all?(value, &(&1 in resolved_list))
          {_, "or"} -> any?(value, &(&1 in resolved_list))
          _ -> raise("this does not make any sense: #{inspect({resolved_list, op, value})}")
        end
      end

    # dbg({all_resolved, filter_results, {op, value}})

    any?(filter_results)
  end

  defp resolve_scope(item, scope) do
    case get_in(item, scope) do
      [_ | _] = list -> list
      resolved -> [resolved]
    end
  end

  # https://gateway.knx.local/api/v1/functions?
  # page[number]=4&page[size]=65536&
  # filter[meta.@type]=Room&
  # filter[hasLocationUsage]=airport&
  # filter[orderNumber]=5WG100-200-AB
end
