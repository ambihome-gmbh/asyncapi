defmodule ComplexTest do
  use ExUnit.Case

  alias MqttAsyncapi.Message

  def start_broker(), do: {"nanomq\n", 0} = System.cmd("docker", ["start", "nanomq"])
  def stop_broker(), do: System.cmd("docker", ["stop", "nanomq"])

  setup do
    start_broker()
    on_exit(&stop_broker/0)

    {:ok, state} =
      MqttAsyncapi.init(
        user_module: DummyUser,
        asyncapi_schema_path: "test/schema/complex/user_schema.json"
      )

    {:ok, state: state}
  end

  test "push pop", context do

    # """
    # user->service: create{name: 'SomeName'}
    # service->user: create_response{name: 'SomeName', id: stack_id}
    # user->service: push/$stack_id{value: 42}
    # user->service: pop/$stack_id{}
    # serivce->user: pop_response/$stack_id{value: 42}
    # """

    # """
    # user->service: create_timer{cron: '0 0 0 *', action: ...}
    # cron->service: cron-event{cron: '0 0 0 *'}
    # """
    {:ok, _} = start_supervised({Complex.ComplexService, []})

    MqttAsyncapi.send("create", %{"name" => "SomeName"}, context.state)

    assert_receive({:publish, mqtt_message})

    assert {
             :ok,
             %MqttAsyncapi.Message{
               operation_id: "create_response",
               payload: %{"name" => "SomeName", "id" => stack_id}
             }
           } = Message.from_mqtt_message(mqtt_message, context.state.asyncapi)

    MqttAsyncapi.sendp("push", %{"value" => 42}, %{"stack_id" => stack_id}, context.state)
    MqttAsyncapi.sendp("pop", %{}, %{"stack_id" => stack_id}, context.state)

    :timer.sleep(100)

    assert_receive({:publish, mqtt_message})

    assert {
             :ok,
             %MqttAsyncapi.Message{
               operation_id: "pop_response",
               payload: %{"value" => 42},
               parameters: %{"stack_id" => ^stack_id}
             }
           } = Message.from_mqtt_message(mqtt_message, context.state.asyncapi)
  end
end
